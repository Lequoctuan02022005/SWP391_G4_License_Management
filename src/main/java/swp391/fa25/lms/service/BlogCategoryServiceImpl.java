package swp391.fa25.lms.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import swp391.fa25.lms.dto.blog.BlogCategoryDTO;
import swp391.fa25.lms.dto.blog.CreateBlogCategoryDTO;
import swp391.fa25.lms.dto.blog.UpdateBlogCategoryDTO;
import swp391.fa25.lms.model.BlogCategory;
import swp391.fa25.lms.repository.BlogCategoryRepository;
import swp391.fa25.lms.repository.BlogRepository;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class BlogCategoryServiceImpl implements BlogCategoryService {

    private final BlogCategoryRepository categoryRepository;
    private final BlogRepository blogRepository;

    @Override
    @Transactional
    public BlogCategoryDTO createCategory(CreateBlogCategoryDTO dto) {
        log.info("Creating blog category: {}", dto.getCategoryName());

        // Check if category name already exists
        if (categoryRepository.existsByCategoryNameIgnoreCase(dto.getCategoryName())) {
            throw new RuntimeException("Category name already exists: " + dto.getCategoryName());
        }

        BlogCategory category = new BlogCategory();
        category.setCategoryName(dto.getCategoryName());
        category.setDescription(dto.getDescription());
        category.setIcon(dto.getIcon());

        // Set displayOrder: if not provided, use max + 1
        if (dto.getDisplayOrder() != null) {
            category.setDisplayOrder(dto.getDisplayOrder());
        } else {
            Integer maxOrder = categoryRepository.findMaxDisplayOrder();
            category.setDisplayOrder(maxOrder != null ? maxOrder + 1 : 1);
        }

        // Set status
        try {
            category.setStatus(BlogCategory.Status.valueOf(dto.getStatus().toUpperCase()));
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Invalid status: " + dto.getStatus());
        }

        // Slug will be auto-generated by @PrePersist
        BlogCategory savedCategory = categoryRepository.save(category);
        log.info("Category created successfully with ID: {}", savedCategory.getCategoryId());

        return new BlogCategoryDTO(savedCategory);
    }

    @Override
    @Transactional
    public BlogCategoryDTO updateCategory(UpdateBlogCategoryDTO dto) {
        log.info("Updating category ID: {}", dto.getCategoryId());

        BlogCategory category = categoryRepository.findById(dto.getCategoryId())
                .orElseThrow(() -> new RuntimeException("Category not found"));

        // Check if new name already exists (excluding current category)
        if (!category.getCategoryName().equalsIgnoreCase(dto.getCategoryName())) {
            if (categoryRepository.existsByCategoryNameIgnoreCase(dto.getCategoryName())) {
                throw new RuntimeException("Category name already exists: " + dto.getCategoryName());
            }
        }

        // Update fields
        category.setCategoryName(dto.getCategoryName());
        category.setDescription(dto.getDescription());
        category.setIcon(dto.getIcon());

        if (dto.getDisplayOrder() != null) {
            category.setDisplayOrder(dto.getDisplayOrder());
        }

        // Update status
        BlogCategory.Status newStatus = BlogCategory.Status.valueOf(dto.getStatus().toUpperCase());
        category.setStatus(newStatus);

        // @PreUpdate will handle updatedAt
        BlogCategory updatedCategory = categoryRepository.save(category);
        log.info("Category updated successfully: {}", updatedCategory.getCategoryId());

        return new BlogCategoryDTO(updatedCategory);
    }

    @Override
    @Transactional
    public void deleteCategory(Long categoryId) {
        log.info("Deleting category ID: {}", categoryId);

        BlogCategory category = categoryRepository.findById(categoryId)
                .orElseThrow(() -> new RuntimeException("Category not found"));

        // Check if category has any blogs
        long blogCount = blogRepository.countByCategory(category);
        if (blogCount > 0) {
            throw new RuntimeException("Cannot delete category with existing blogs. " +
                    "Please reassign or delete " + blogCount + " blog(s) first.");
        }

        categoryRepository.delete(category);
        log.info("Category deleted successfully: {}", categoryId);
    }

    @Override
    @Transactional(readOnly = true)
    public BlogCategoryDTO getCategoryById(Long categoryId) {
        BlogCategory category = categoryRepository.findById(categoryId)
                .orElseThrow(() -> new RuntimeException("Category not found"));

        // Get blog count
        long blogCount = blogRepository.countByCategory(category);
        return new BlogCategoryDTO(category, blogCount);
    }

    @Override
    @Transactional(readOnly = true)
    public BlogCategoryDTO getCategoryBySlug(String slug) {
        BlogCategory category = categoryRepository.findBySlug(slug)
                .orElseThrow(() -> new RuntimeException("Category not found"));

        long blogCount = blogRepository.countByCategory(category);
        return new BlogCategoryDTO(category, blogCount);
    }

    @Override
    @Transactional(readOnly = true)
    public List<BlogCategoryDTO> getAllCategories() {
        List<BlogCategory> categories = categoryRepository.findAllOrderByDisplayOrder();
        return categories.stream()
                .map(category -> {
                    long blogCount = blogRepository.countByCategory(category);
                    return new BlogCategoryDTO(category, blogCount);
                })
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<BlogCategoryDTO> getActiveCategories() {
        List<BlogCategory> categories = categoryRepository.findAllActiveOrderByDisplayOrder();
        return categories.stream()
                .map(category -> {
                    long blogCount = blogRepository.countByCategory(category);
                    return new BlogCategoryDTO(category, blogCount);
                })
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<BlogCategoryDTO> getCategoriesWithBlogCount() {
        List<Object[]> results = categoryRepository.findCategoriesWithBlogCount();
        return results.stream()
                .map(result -> {
                    BlogCategory category = (BlogCategory) result[0];
                    Long blogCount = (Long) result[1];
                    return new BlogCategoryDTO(category, blogCount != null ? blogCount : 0L);
                })
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void reorderCategories(Long categoryId1, Long categoryId2) {
        log.info("Swapping display order between categories: {} and {}", categoryId1, categoryId2);

        BlogCategory category1 = categoryRepository.findById(categoryId1)
                .orElseThrow(() -> new RuntimeException("Category 1 not found"));
        BlogCategory category2 = categoryRepository.findById(categoryId2)
                .orElseThrow(() -> new RuntimeException("Category 2 not found"));

        // Swap display orders
        Integer tempOrder = category1.getDisplayOrder();
        category1.setDisplayOrder(category2.getDisplayOrder());
        category2.setDisplayOrder(tempOrder);

        categoryRepository.save(category1);
        categoryRepository.save(category2);

        log.info("Display orders swapped successfully");
    }

    @Override
    @Transactional
    public void updateDisplayOrder(Long categoryId, Integer newDisplayOrder) {
        log.info("Updating display order of category {} to {}", categoryId, newDisplayOrder);

        BlogCategory category = categoryRepository.findById(categoryId)
                .orElseThrow(() -> new RuntimeException("Category not found"));

        Integer oldDisplayOrder = category.getDisplayOrder();
        
        if (oldDisplayOrder.equals(newDisplayOrder)) {
            return; // No change needed
        }

        // Get affected categories
        List<BlogCategory> affectedCategories;
        if (newDisplayOrder > oldDisplayOrder) {
            // Moving down: shift others up
            affectedCategories = categoryRepository.findByDisplayOrderBetween(
                    oldDisplayOrder + 1, newDisplayOrder);
            affectedCategories.forEach(cat -> cat.setDisplayOrder(cat.getDisplayOrder() - 1));
        } else {
            // Moving up: shift others down
            affectedCategories = categoryRepository.findByDisplayOrderBetween(
                    newDisplayOrder, oldDisplayOrder - 1);
            affectedCategories.forEach(cat -> cat.setDisplayOrder(cat.getDisplayOrder() + 1));
        }

        category.setDisplayOrder(newDisplayOrder);
        
        categoryRepository.saveAll(affectedCategories);
        categoryRepository.save(category);

        log.info("Display order updated successfully");
    }

    @Override
    @Transactional
    public BlogCategoryDTO activateCategory(Long categoryId) {
        log.info("Activating category ID: {}", categoryId);

        BlogCategory category = categoryRepository.findById(categoryId)
                .orElseThrow(() -> new RuntimeException("Category not found"));

        category.setStatus(BlogCategory.Status.ACTIVE);
        BlogCategory savedCategory = categoryRepository.save(category);

        log.info("Category activated successfully: {}", categoryId);
        return new BlogCategoryDTO(savedCategory);
    }

    @Override
    @Transactional
    public BlogCategoryDTO deactivateCategory(Long categoryId) {
        log.info("Deactivating category ID: {}", categoryId);

        BlogCategory category = categoryRepository.findById(categoryId)
                .orElseThrow(() -> new RuntimeException("Category not found"));

        category.setStatus(BlogCategory.Status.INACTIVE);
        BlogCategory savedCategory = categoryRepository.save(category);

        log.info("Category deactivated successfully: {}", categoryId);
        return new BlogCategoryDTO(savedCategory);
    }

    @Override
    @Transactional(readOnly = true)
    public boolean isCategoryNameExists(String categoryName) {
        return categoryRepository.existsByCategoryNameIgnoreCase(categoryName);
    }

    @Override
    @Transactional(readOnly = true)
    public long countByStatus(BlogCategory.Status status) {
        return categoryRepository.countByStatus(status);
    }
}
